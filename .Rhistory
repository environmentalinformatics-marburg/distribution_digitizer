png("D:/MSc_Phys_Geo/upscaling_project/depictions/scatter_SRplants.png",
width = 1200, height = 600, res = 150)
featurePlot(x = srplants[, predictors],
y = srplants$Plant_SR, type = c("p", "smooth"),
plot = "scatter", layout = c(3,3), col = "darkred")
dev.off()
png("D:/MSc_Phys_Geo/upscaling_project/depictions/scatter_SRplants.png",
width = 1200, height = 800, res = 150)
featurePlot(x = srplants[, predictors],
y = srplants$Plant_SR, type = c("p", "smooth"),
plot = "scatter", layout = c(3,3), col = "darkred")
dev.off()
srpoll = read.csv("D:/MSc_Phys_Geo/upscaling_project/data/plot_level/combined/pred_SRpoll.csv")
# do some indexing and change column names
colnames(srpoll)
srpoll = srpoll[,-1]
colnames(srpoll) = c("PlotID", "Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI", "SD_of_NDVI",
"SD_of_SAVI", "Pollinator_SR", "Category")
# isolate colnames of predictor variables
predictors <- c("Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI")
# plot scatterplots and save as png file
png("D:/MSc_Phys_Geo/upscaling_project/depictions/scatter_SRpoll.png",
width = 1200, height = 1200, res = 150)
featurePlot(x = srpoll[, predictors],
y = srpoll$Pollinator_SR, type = c("p", "smooth"),
plot = "scatter", layout = c(3,3), col = "darkred")
dev.off()
spfi = read.csv("D:/MSc_Phys_Geo/upscaling_project/data/plot_level/combined/pred_index.csv")
# do some indexing and change column names
colnames(spfi)
spfi = spfi[,-1]
colnames(spfi) = c("PlotID", "Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI", "SD_of_NDVI",
"SD_of_SAVI", "SPFI", "Category")
# isolate colnames of predictor variables
predictors <- c("Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI")
# plot scatterplots and save as png file
png("D:/MSc_Phys_Geo/upscaling_project/depictions/scatter_SPFI.png",
width = 1200, height = 1200, res = 150)
featurePlot(x = spfi[, predictors],
y = spfi$SPFI, type = c("p", "smooth"),
plot = "scatter", layout = c(3,3), col = "darkred")
dev.off()
srpoll = read.csv("D:/MSc_Phys_Geo/upscaling_project/data/plot_level/combined/pred_SRpoll.csv")
# do some indexing and change column names
colnames(srpoll)
srpoll = srpoll[,-1]
colnames(srpoll) = c("PlotID", "Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI", "SD_of_NDVI",
"SD_of_SAVI", "Pollinator_SR", "Category")
# isolate colnames of predictor variables
predictors <- c("Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI")
# plot scatterplots and save as png file
png("D:/MSc_Phys_Geo/upscaling_project/depictions/scatter_SRpoll.png",
width = 1200, height = 800, res = 150)
featurePlot(x = srpoll[, predictors],
y = srpoll$Pollinator_SR, type = c("p", "smooth"),
plot = "scatter", layout = c(3,3), col = "darkred")
dev.off()
spfi = read.csv("D:/MSc_Phys_Geo/upscaling_project/data/plot_level/combined/pred_index.csv")
# do some indexing and change column names
colnames(spfi)
spfi = spfi[,-1]
colnames(spfi) = c("PlotID", "Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI", "SD_of_NDVI",
"SD_of_SAVI", "SPFI", "Category")
# isolate colnames of predictor variables
predictors <- c("Mean_minimum_temperature", "Mean_maximum_temperature",
"Average_temperature", "Total_Precipitation", "Mean_elevation",
"Mean_aspect", "Mean_slope", "Mean_NDVI", "Mean_SAVI")
# plot scatterplots and save as png file
png("D:/MSc_Phys_Geo/upscaling_project/depictions/scatter_SPFI.png",
width = 1200, height = 800, res = 150)
featurePlot(x = spfi[, predictors],
y = spfi$SPFI, type = c("p", "smooth"),
plot = "scatter", layout = c(3,3), col = "darkred")
dev.off()
library(reticulate)
reticulate::repl_python()
input_start = "20230828:0800"
input_end = "20230828:1200"
START = dt.datetime.strptime(input_start, "%Y%m%d:%H%M")
from datetime import timedelta
import datetime as dt
from datetime import timedelta # Added on 2023-08-29 for time period splitting
START = dt.datetime.strptime(input_start, "%Y%m%d:%H%M")
END = dt.datetime.strptime(input_end, "%Y%m%d:%H%M")
time_period = timedelta(hours=1)
current_time = START
START_LIST = []
END_LIST = []
time_period = timedelta(hours=1)
current_time = START
while current_time < END:
next_time = current_time + time_period
# if-statement for exiting while condition, when the END timestamp is reached
if next_time > END:
next_time = END
START_LIST.append(current_time)
END_LIST.append(next_time)
current_time = next_time
while current_time < END:
next_time = current_time + time_period
# if-statement for exiting while condition, when the END timestamp is reached
if next_time > END:
next_time = END
START_LIST.append(current_time)
END_LIST.append(next_time)
current_time = next_time
START_LIST
END_LIST
library(reticulate) # Python binding for R.
setwd("D:/dd/2023-10-17/distribution_digitizer") # uncomment this line for setting the working directory manually.
library(shiny) # shiny library necessary for starting the app
getwd() # print the path to the working directory for copying into the Digitizer application (Field: "Working Directory").
# start the main app
runApp('app.R') # the app itself
reticulate::repl_python()
def edge(tiffile, outdir, n, m):
# Load image, grayscale, Otsu's threshold
ig = np.array(PIL.Image.open(tiffile))
gray = cv2.cvtColor(ig, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (m, m), 0)
ret, thresh = cv2.threshold(gray, 120, 255, cv2.THRESH_TOZERO_INV)
# Morph open using elliptical shaped kernel
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (n, n))
opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=3)
# Plot the mask
contours, hierarchy = cv2.findContours(opening, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
# Draw all contours and centroids
image = ig.copy()  # Create a copy of the original image
for contour in contours:
# Draw the contour
image = cv2.drawContours(image, [contour], -1, (0, 0, 255), 3)
# Calculate the centroid of the contour
M = cv2.moments(contour)
if M["m00"] != 0:
cX = int(M["m10"] / M["m00"])
cY = int(M["m01"] / M["m00"])
# Draw a red pixel at the centroid
image[cY, cX] = (0, 0, 255)
# Save the image with contours and centroids
PIL.Image.fromarray(image, 'RGB').save(os.path.join(outdir, os.path.basename(tiffile))
PIL.Image.fromarray(image, 'RGB').save(os.path.join(outdir, os.path.basename(tiffile)))
def edge(tiffile, outdir, n, m):
# Load image, grayscale, Otsu's threshold
ig = np.array(PIL.Image.open(tiffile))
gray = cv2.cvtColor(ig, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (m, m), 0)
ret, thresh = cv2.threshold(gray, 120, 255, cv2.THRESH_TOZERO_INV)
# Morph open using elliptical shaped kernel
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (n, n))
opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=3)
# Plot the mask
contours, hierarchy = cv2.findContours(opening, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
# Draw all contours and centroids
image = ig.copy()  # Create a copy of the original image
for contour in contours:
# Draw the contour
image = cv2.drawContours(image, [contour], -1, (0, 0, 255), 3)
# Calculate the centroid of the contour
M = cv2.moments(contour)
if M["m00"] != 0:
cX = int(M["m10"] / M["m00"])
cY = int(M["m01"] / M["m00"])
# Draw a red pixel at the centroid
image[cY, cX] = (0, 0, 255)
# Save the image with contours and centroids
PIL.Image.fromarray(image, 'RGB').save(os.path.join(outdir, os.path.basename(tiffile)))
quit
# start the main app
runApp('app.R') # the app itself
# start the main app
runApp('app.R') # the app itself
# start the main app
runApp('app.R') # the app itself
# start the main app
runApp('app.R') # the app itself
# start the main app
runApp('app.R') # the app itself
reticulate::repl_python()
# define functions for initializing csv file
def initialize_csv_file(output_dir):
csv_file_path = os.path.join(output_dir, "coordinates.csv")
if not os.path.exists(csv_file_path):
with open(csv_file_path, mode='w', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerow(['File', 'Detection method', 'X', 'Y'])
return csv_file_path
# define function for appending existing csv file
def append_to_csv_file(csv_file_path, coordinates, file_name, method):
with open(csv_file_path, mode='a', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerows([(file_name, method, x, y) for x, y in coordinates])
def initialize_csv_file(output_dir):
csv_file_path = os.path.join(output_dir, "coordinates.csv")
if not os.path.exists(csv_file_path):
with open(csv_file_path, mode='w', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerow(['File', 'Detection method', 'X', 'Y'])
return csv_file_path
def append_to_csv_file(csv_file_path, coordinates, file_name, method):
with open(csv_file_path, mode='a', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerows([(file_name, method, x, y) for x, y in coordinates])
quit
# start the main app
runApp('app.R') # the app itself
reticulate::repl_python()
# define functions for initializing csv file
def initialize_csv_file(output_dir):
csv_file_path = os.path.join(output_dir, "coordinates.csv")
if not os.path.exists(csv_file_path):
with open(csv_file_path, mode='w', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerow(['File', 'Detection method', 'X', 'Y'])
return csv_file_path
# define function for appending existing csv file
def append_to_csv_file(csv_file_path, coordinates, file_name, method):
with open(csv_file_path, mode='a', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerows([(file_name, method, x, y) for x, y in coordinates])
def initialize_csv_file(output_dir):
csv_file_path = os.path.join(output_dir, "coordinates.csv")
if not os.path.exists(csv_file_path):
with open(csv_file_path, mode='w', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerow(['File', 'Detection method', 'X', 'Y'])
return csv_file_path
# define fun
def append_to_csv_file(csv_file_path, coordinates, file_name, method):
with open(csv_file_path, mode='a', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerows([(file_name, method, x, y) for x, y in coordinates])
def initialize_csv_file(output_dir):
csv_file_path = os.path.join(output_dir, "coordinates.csv")
if not os.path.exists(csv_file_path):
with open(csv_file_path, mode='w', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerow(['File', 'Detection method', 'X', 'Y'])
return csv_file_path
def append_to_csv_file(csv_file_path, coordinates, file_name, method):
with open(csv_file_path, mode='a', newline='') as csv_file:
csv_writer = csv.writer(csv_file)
csv_writer.writerows([(file_name, method, x, y) for x, y in coordinates])
quit
# start the main app
runApp('app.R') # the app itself
# start the main app
runApp('app.R') # the app itself
reticulate::repl_python()
def mainPointFiltering(workingDir, n, m):
inputDir = workingDir+"/data/output/maps/align/"
ouputTifDir = workingDir+"/data/output/maps/pointFiltering/"
os.makedirs(ouputTifDir, exist_ok=True)
print(inputDir)
print(ouputTifDir)
print(n)
print(m)
outputCsvDir = workingDir + "/data/output/maps/csv_files/"
os.makedirs(outputCsvDir, exist_ok=True)
csv_file_path = initialize_csv_file(outputCsvDir)
ouputPngDir = workingDir+"/www/pointFiltering_png/"
os.makedirs(ouputPngDir, exist_ok=True)
for file in glob.glob(inputDir + '*.tif'):
print(file)
centroids, output_file = edge(file, ouputTifDir, int(n), int(m))
append_to_csv_file(csv_file_path, centroids, os.path.basename(file), "point_filtering")
View(append_to_csv_file)
View(append_to_csv_file)
del initialize_csv_file
del append_to_csv_file
del circle_detection
del edge
del mainCircleDetection()
del mainCircleDetection
del mainPointFiltering
quit
# start the main app
runApp('app.R') # the app itself
# Gegeben
ared = 1000 # Versiegelungsfläche [m^2]
kf_nord_min = 0.000133333 # Minimalwert kf-Wert (worst-case)
#### Angenommene Fläche von 25 m^2 für As
as = 25
# Erstellen Sie ein leeres DataFrame, um die Ergebnisse zu speichern
ergebnisse_as25 <- data.frame(dauer = numeric(), spende = numeric(), vs = numeric())
# Gegeben
ared = 1000 # Versiegelungsfläche [m^2]
kf_nord_min = 0.000133333 # Minimalwert kf-Wert (worst-case)
#### Angenommene Fläche von 25 m^2 für As
as = 25
# Erstellen Sie ein leeres DataFrame, um die Ergebnisse zu speichern
ergebnisse_as25 <- data.frame(dauer = numeric(), spende = numeric(), vs = numeric())
# Schleife durch die Zeilen des kostra_5a DataFrames
for (i in 1:nrow(kostra_5a)) {
# Holen Sie die Werte für dauer und spende aus kostra_5a
t <- kostra_5a$dauer[i]
rn <- kostra_5a$spende[i]
# Berechnen Sie vs mit den aktuellen Werten von t und rn
vs <- ((ared + as) * 10^(-7) * rn * t * 60) - (as * t * 60 * (kf_nord_min/2))
# Fügen Sie die Werte zu Ihrem Ergebnis-DataFrame hinzu
ergebnisse_as25 <- rbind(ergebnisse_as25, data.frame(dauer = t, spende = rn, vs = vs))
}
ergebnisse_as25
kostra_5a = df(dauer = c(5, 10, 15, 20, 30, 45, 60, 90, 120, 180, 240, 360, 540, 720, 1080, 1440, 2880, 4320),
spende = c(310, 225, 182.2, 155, 121.1, 92.2, 75.3, 53.3, 41.8, 29.5, 23.2, 16.4, 11.7, 9.2, 6.5, 5.1, 3.2, 2.5))
kostra_5a = data.frame(dauer = c(5, 10, 15, 20, 30, 45, 60, 90, 120, 180, 240, 360, 540, 720, 1080, 1440, 2880, 4320),
spende = c(310, 225, 182.2, 155, 121.1, 92.2, 75.3, 53.3, 41.8, 29.5, 23.2, 16.4, 11.7, 9.2, 6.5, 5.1, 3.2, 2.5))
#### Angenommene Fläche von 25 m^2 für As
as = 25
# Erstellen Sie ein leeres DataFrame, um die Ergebnisse zu speichern
ergebnisse_as25 <- data.frame(dauer = numeric(), spende = numeric(), vs = numeric())
# Schleife durch die Zeilen des kostra_5a DataFrames
for (i in 1:nrow(kostra_5a)) {
# Holen Sie die Werte für dauer und spende aus kostra_5a
t <- kostra_5a$dauer[i]
rn <- kostra_5a$spende[i]
# Berechnen Sie vs mit den aktuellen Werten von t und rn
vs <- ((ared + as) * 10^(-7) * rn * t * 60) - (as * t * 60 * (kf_nord_min/2))
# Fügen Sie die Werte zu Ihrem Ergebnis-DataFrame hinzu
ergebnisse_as25 <- rbind(ergebnisse_as25, data.frame(dauer = t, spende = rn, vs = vs))
}
# Ergebnisse anzeigen
print(ergebnisse_as25)
#### Angenommene Fläche von 50 m^2 für As
as = 50
# Erstellen Sie ein leeres DataFrame, um die Ergebnisse zu speichern
ergebnisse_as50 <- data.frame(dauer = numeric(), spende = numeric(), vs = numeric())
# Schleife durch die Zeilen des kostra_5a DataFrames
for (i in 1:nrow(kostra_5a)) {
# Holen Sie die Werte für dauer und spende aus kostra_5a
t <- kostra_5a$dauer[i]
rn <- kostra_5a$spende[i]
# Berechnen Sie vs mit den aktuellen Werten von t und rn
vs <- ((ared + as) * 10^(-7) * rn * t * 60) - (as * t * 60 * (kf_nord_min/2))
# Fügen Sie die Werte zu Ihrem Ergebnis-DataFrame hinzu
ergebnisse_as50 <- rbind(ergebnisse_as50, data.frame(dauer = t, spende = rn, vs = vs))
}
# Ergebnisse anzeigen
print(ergebnisse_as50)
#### Angenommene Fläche von 75 m^2 für As
as = 75
# Erstellen Sie ein leeres DataFrame, um die Ergebnisse zu speichern
ergebnisse_as75 <- data.frame(dauer = numeric(), spende = numeric(), vs = numeric())
# Schleife durch die Zeilen des kostra_5a DataFrames
for (i in 1:nrow(kostra_5a)) {
# Holen Sie die Werte für dauer und spende aus kostra_5a
t <- kostra_5a$dauer[i]
rn <- kostra_5a$spende[i]
# Berechnen Sie vs mit den aktuellen Werten von t und rn
vs <- ((ared + as) * 10^(-7) * rn * t * 60) - (as * t * 60 * (kf_nord_min/2))
# Fügen Sie die Werte zu Ihrem Ergebnis-DataFrame hinzu
ergebnisse_as75 <- rbind(ergebnisse_as75, data.frame(dauer = t, spende = rn, vs = vs))
}
# Ergebnisse anzeigen
print(ergebnisse_as75)
#### Angenommene Fläche von 100 m^2 für As
as = 100
# Erstellen Sie ein leeres DataFrame, um die Ergebnisse zu speichern
ergebnisse_as100 <- data.frame(dauer = numeric(), spende = numeric(), vs = numeric())
# Schleife durch die Zeilen des kostra_5a DataFrames
for (i in 1:nrow(kostra_5a)) {
# Holen Sie die Werte für dauer und spende aus kostra_5a
t <- kostra_5a$dauer[i]
rn <- kostra_5a$spende[i]
# Berechnen Sie vs mit den aktuellen Werten von t und rn
vs <- ((ared + as) * 10^(-7) * rn * t * 60) - (as * t * 60 * (kf_nord_min/2))
# Fügen Sie die Werte zu Ihrem Ergebnis-DataFrame hinzu
ergebnisse_as100 <- rbind(ergebnisse_as100, data.frame(dauer = t, spende = rn, vs = vs))
}
# Ergebnisse anzeigen
print(ergebnisse_as100)
## ausschreiben der ergebnisse
write.csv(ergebnisse_as25, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As25.csv")
write.csv(ergebnisse_as50, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As50.csv")
write.csv(ergebnisse_as75, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As75.csv")
write.csv(ergebnisse_as100, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As100.csv")
print(ergebnisse_as25)
print(ergebnisse_as50)
print(ergebnisse_as75)
print(ergebnisse_as100)
## für as = 25
as = 25
rn_plus15 = 75.3 + 75.3*0.15
rn_minus15 = 75.3 - 75.3*0.15
t_plus15 = 60 + 60*0.15
t_minus15 = 60 - 60*0.15
vs_bei_as25_1 <- ((ared + as) * 10^(-7) * rn_plus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as25_2 <- ((ared + as) * 10^(-7) * rn_plus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as25_3 <- ((ared + as) * 10^(-7) * rn_minus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as25_4 <- ((ared + as) * 10^(-7) * rn_minus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as25_toleranz = data.frame(c(vs_bei_as25_1, vs_bei_as25_3),
c(vs_bei_as25_2, vs_bei_as25_4))
colnames(vs_bei_as25_toleranz) = c("rn +15%", "rn -15%")
rownames(vs_bei_as25_toleranz) = c("t +15%", "t -15%")
rn_plus15 = 92.2 + 92.2*0.15
rn_minus15 = 92.2 - 92.2
rn_plus15 = 92.2 + 92.2*0.15
rn_minus15 = 92.2 - 92.2*0.15
t_plus15 = 45 + 45*0.15
t_minus15 = 45 - 45*0.15
# Einsetzen in Formel
vs_bei_as50_1 <- ((ared + as) * 10^(-7) * rn_plus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as50_2 <- ((ared + as) * 10^(-7) * rn_plus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as50_3 <- ((ared + as) * 10^(-7) * rn_minus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as50_4 <- ((ared + as) * 10^(-7) * rn_minus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as50_toleranz = data.frame(c(vs_bei_as50_1, vs_bei_as50_3),
c(vs_bei_as50_2, vs_bei_as50_4))
colnames(vs_bei_as50_toleranz) = c("rn +15%", "rn -15%")
rownames(vs_bei_as50_toleranz) = c("t +15%", "t -15%")
as = 50
rn_plus15 = 92.2 + 92.2*0.15
rn_minus15 = 92.2 - 92.2*0.15
t_plus15 = 45 + 45*0.15
t_minus15 = 45 - 45*0.15
# Einsetzen in Formel
vs_bei_as50_1 <- ((ared + as) * 10^(-7) * rn_plus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as50_2 <- ((ared + as) * 10^(-7) * rn_plus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as50_3 <- ((ared + as) * 10^(-7) * rn_minus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as50_4 <- ((ared + as) * 10^(-7) * rn_minus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as50_toleranz = data.frame(c(vs_bei_as50_1, vs_bei_as50_3),
c(vs_bei_as50_2, vs_bei_as50_4))
colnames(vs_bei_as50_toleranz) = c("rn +15%", "rn -15%")
rownames(vs_bei_as50_toleranz) = c("t +15%", "t -15%")
as = 75
rn_plus15 = 121.1 + 121.1*0.15
rn_minus15 = 121.1 - 121.1*0.15
t_plus15 = 30 + 30*0.15
t_minus15 = 30 - 30*0.15
vs_bei_as75_1 <- ((ared + as) * 10^(-7) * rn_plus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as75_2 <- ((ared + as) * 10^(-7) * rn_plus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as75_3 <- ((ared + as) * 10^(-7) * rn_minus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as75_4 <- ((ared + as) * 10^(-7) * rn_minus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as75_toleranz = data.frame(c(vs_bei_as75_1, vs_bei_as75_3),
c(vs_bei_as75_2, vs_bei_as75_4))
colnames(vs_bei_as75_toleranz) = c("rn +15%", "rn -15%")
rownames(vs_bei_as75_toleranz) = c("t +15%", "t -15%")
## für as = 100
as = 100
rn_plus15 = 155 + 155*0.15
rn_minus15 = 155 - 155*0.15
t_plus15 = 20 + 20*0.15
t_minus15 = 20 - 20*0.15
vs_bei_as100_1 <- ((ared + as) * 10^(-7) * rn_plus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as100_2 <- ((ared + as) * 10^(-7) * rn_plus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as100_3 <- ((ared + as) * 10^(-7) * rn_minus15 * t_plus15 * 60) - (as * t_plus15 * 60 * (kf_nord_min/2))
vs_bei_as100_4 <- ((ared + as) * 10^(-7) * rn_minus15 * t_minus15 * 60) - (as * t_minus15 * 60 * (kf_nord_min/2))
vs_bei_as100_toleranz = data.frame(c(vs_bei_as100_1, vs_bei_as100_3),
c(vs_bei_as100_2, vs_bei_as100_4))
colnames(vs_bei_as100_toleranz) = c("rn +15%", "rn -15%")
rownames(vs_bei_as100_toleranz) = c("t +15%", "t -15%")
### Ausschreiben der Ergebnisse
write.csv(vs_bei_as25_toleranz, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As25_mit_Toleranzen_fuer_maximalen_Vs.csv")
write.csv(vs_bei_as50_toleranz, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As50_mit_Toleranzen_fuer_maximalen_Vs.csv")
write.csv(vs_bei_as75_toleranz, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As75_mit_Toleranzen_fuer_maximalen_Vs.csv")
write.csv(vs_bei_as100_toleranz, "D:/MSc_Phys_Geo/geomorph/rechnungen/Vs_fuer_As100_mit_Toleranzen_fuer_maximalen_Vs.csv")
vs_bei_as100_toleranz
vs_bei_as100_1
vs_bei_as100_2
vs_bei_as100_3
vs_bei_as100_4
# für as = 25
as = 25
h_as25 = vs_bei_as25_1/as
# für as = 50
as = 50
h_as50 = vs_bei_as50_1/as
# für as = 75
as = 75
h_as75 = vs_bei_as75_1/as
# für as = 100
as = 100
h_as100 = vs_bei_as100_1/as
# Muldentiefen
muldentiefen = data.frame(c(vs_bei_as25_1, vs_bei_as50_1, vs_bei_as75_1, vs_bei_as100_1),
c(h_as25, h_as50, h_as75, h_as100))
colnames(muldentiefen) = c("Maximales benötigtes Volumen unter Einbezug der Toleranzbeträge [m^3]", "Muldentiefe [m]")
rownames(muldentiefen) = c("As = 25 m^2", "As = 50 m^2", "As = 75 m^2", "As = 100 m^2")
print(muldentiefen)
write.csv(muldentiefen, "D:/MSc_Phys_Geo/geomorph/rechnungen/benoetigte_muldentiefen.csv")
# start the main app
runApp('app.R') # the app itself
# start the main app
runApp('app.R') # the app itself
setwd("D:/dd/2023-10-17/distribution_digitizer") # uncomment this line for setting the working directory manually.
getwd() # print the path to the working directory for copying into the Digitizer application (Field: "Working Directory").
library(shiny) # shiny library necessary for starting the app
# start the main app
runApp('app.R') # the app itself
runApp('app.R')
.rs.restartR()
library(reticulate) # Python binding for R.
setwd("D:/dd/2023-10-17/distribution_digitizer") # uncomment this line for setting the working directory manually.
getwd() # print the path to the working directory for copying into the Digitizer application (Field: "Working Directory").
library(shiny) # shiny library necessary for starting the app
# start the main app
runApp('app.R') # the app itself
getwd() # print the path to the working directory for copying into the Digitizer application (Field: "Working Directory").
# start the main app
runApp('app.R') # the app itself
